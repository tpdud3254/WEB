<html>

<head>
</head>

<body>
  <div id="root"></div> <!-- 컴포넌트들을 렌더링할 루트 -->
  <!-- 결과 : <div id="root"><button>Like</button></div> -> 이렇게 결과를 예측할 수 있어야 함 -->
  <script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
  <!--<script src="https://unpkg.com/react@16/umd/react.production.min.js" crossorigin></script>-->
  <!--<script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js" crossorigin></script>-->
  <script>
    'use strict';

    const e = React.createElement; //createElement - html태그를 만든다고 생각

    class LikeButton extends React.Component { //클래스 하나가 컴포넌트 하나라고 생각하면됨
      constructor(props) {
        super(props); //컴포넌트가 실행될때 제일 먼저 실행되는 부분, 그냥 기본적으로 쓰는거라고 생각하기
        this.state = { // 상태(state) : 바뀌는 부분 바뀔 수 있는 부분
          liked: false
        };
      }

      render() { // 좋아요버튼을 어떻게 화면에 표시해줄것인지 결정해주는 매쏘드, 태그를 만들어주는 함수

        //return e('button', null, 'Like');  -> <button>Like</button> 이런 태그를 만들'겠'다 (바로 만드는게 X)

        if (this.state.liked) {
          return 'You liked this.';
        }

        return e('button', {
          onClick: () => {
            this.setState({ //HTML 속성을 넣는 자리 (객체 형식으로 표현)
              // html 속성을 js로 표현할땐 카멜케이스
              liked: true
            })
          },
          type: 'submit'
        }, 'Like');
        // -> <button onclick:'() => this.setState({liked: true})' type='submit'>Like</button>

        // 정리 : return e(태그, 속성(객체형식), 내용)
      }
    }
  </script>
  <script>
    ReactDOM.render(e(LikeButton), document.querySelector('#root')); //화면에 실제로 반영 / e(클래스이름)를 root안에다가 실제로 붙이겠다
  </script>
</body>

</html>